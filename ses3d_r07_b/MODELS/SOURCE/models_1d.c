//
//    MODEL_1D.C -- 1D models
//

#include <stdio.h>
#include "gm.h"

// homogeneous model
  void homogeneous(void) {
      const real h_rho = 1.0;
      const real h_mu = 0.0;
      const real h_lambda = 0.0;
      const real h_A = 0.0;
      const real h_B = 0.0;
      const real h_C = 0.0;

      FOR_MD (IM) {
          rhoinv[IM] = 1.0 / h_rho;
          mu[IM] = h_mu;
          lambda[IM] = h_lambda;
          A[IM] = h_A;
          B[IM] = h_B;
          C[IM] = h_C;
          }
      }

// isotropic version of prem
  void prem_iso(void) {
      real **cp1d = new_ZD();
      real **cs1d = new_ZD();
      real **rho1d = new_ZD();
      real **Q1d = new_ZD();

    // make elastic model
    
      FOR_ZD (i, k) {
          real r = z[i][k] / 6371.0e3;
          real r2 = r * r;
          real r3 = r2 * r;

        // crust
		
          if (z[i][k]<=6371000.0 && z[i][k] >= 6356000.0) {    // 0-15km			  
              rho1d[i][k] = 2.60;
              cp1d[i][k] = 5.80;
              cs1d[i][k] = 3.20;
              }

          else if (z[i][k] <= 6356000.0 && z[i][k] >= 6346600.0) {    // 15-24.4km
              rho1d[i][k] = 2.90;
              cp1d[i][k] = 6.80;
              cs1d[i][k] = 3.90;
              }

        // LID

          else if (z[i][k] <= 6346600.0 && z[i][k] >= 6291000.0) {    // 24-80 km
              rho1d[i][k] = 2.6910 + 0.6924 * r;
              cp1d[i][k] = 4.1875 + 3.9382 * r;
              cs1d[i][k] = 2.1519 + 2.3481 * r;
              }
              
        // LVZ
        
          else if (z[i][k] <= 6291000.0 && z[i][k] >= 6151000.0) {    // 80-220 km
              rho1d[i][k] = 2.6910 + 0.6924 * r;
              cp1d[i][k] = 4.1875 + 3.9382 * r;
              cs1d[i][k] = 2.1519 + 2.3481 * r;
              }

        // Transition zone

          else if (z[i][k] <= 6151000.0 && z[i][k] >= 5971000.0) {    // 220-400 km
              rho1d[i][k] = 7.1089 - 3.8045 * r;
              cp1d[i][k] = 20.3926 - 12.2569 * r;
              cs1d[i][k] = 8.9496 - 4.4597 * r;
              }

          else if (z[i][k] <= 5971000.0 && z[i][k] >= 5771000.0) {    // 400-600 km
              rho1d[i][k] = 11.2494 - 8.0298 * r;
              cp1d[i][k] = 39.7027 - 32.6166 * r;
              cs1d[i][k] = 22.3512 - 18.5856 * r;
              }

          else if (z[i][k] <= 5771000.0 && z[i][k] >= 5701000.0) {    // 600-670 km
              rho1d[i][k] = 5.3197 - 1.4836 * r;
              cp1d[i][k] = 19.0957 - 9.8672 * r;
              cs1d[i][k] = 9.9839 - 4.9324 * r;
              }

        // Lower mantle

          else if (z[i][k] <= 5701000.0 && z[i][k] >= 5600000.0) {    // 670-771 km
              rho1d[i][k] = 7.9565 - 6.4761 * r + 5.5283 * r2 - 3.0807 * r3;
              cp1d[i][k] = 29.2766 - 23.6026 * r + 5.5242 * r2 - 2.5514 * r3;
              cs1d[i][k] = 22.3459 - 17.2473 * r - 2.0834 * r2 + 0.9783 * r3;
              }

          else if (z[i][k] <= 5600000.0 && z[i][k] >= 3630000.0) {    // 771-2741 km
              rho1d[i][k] = 7.9565 - 6.4761 * r + 5.5283 * r2 - 3.0807 * r3;
              cp1d[i][k] = 24.9520 - 40.4673 * r + 51.4832 * r2 - 26.6419 * r3;
              cs1d[i][k] = 11.1671 - 13.7818 * r + 17.4575 * r2 - 9.2777 * r3;
              }

          else if (z[i][k] <= 3630000.0 && z[i][k] >= 3480000.0) {    // 2741-2756 km
              rho1d[i][k] = 7.9565 - 6.4761 * r + 5.5283 * r2 - 3.0807 * r3;
              cp1d[i][k] = 15.3891 - 5.3181 * r + 5.5242 * r2 - 2.5514 * r3;
              cs1d[i][k] = 6.9254 + 1.4672 * r - 2.0834 * r2 + 0.9783 * r3;
              }

        // Outer core

          else if (z[i][k] <= 3480000.0 && z[i][k] >= 1221500.0) {
              rho1d[i][k] = 12.5815 - 1.2638 * r - 3.6426 * r2 - 5.5281 * r3;
              cp1d[i][k] = 11.0487 - 4.0362 * r + 4.8023 * r2 - 13.5732 * r3;
              cs1d[i][k] = 0.0;
              }

        // Inner core

          else if (z[i][k] <= 1221500.0) {
              rho1d[i][k] = 13.0885 - 8.8381 * r2;
              cp1d[i][k] = 11.2622 - 6.3640 * r2;
              cs1d[i][k] = 3.6678 - 4.4475 * r2;
              }
              
          }

    // make Q model
    
      if (is_diss) {
          FOR_ZD (i, k) {

            // crust
		
              if (z[i][k] <= 6371000.0 && z[i][k] >= 6356000.0)    // 0-15km
                  Q1d[i][k] = 600.0;	

              else if (z[i][k] <= 6356000.0 && z[i][k] >= 6346600.0)    // 15-24.4km
                  Q1d[i][k] = 600.0;	

            // LID

              else if (z[i][k] <= 6346600.0 && z[i][k] >= 6291000.0)    // 24-80 km
                  Q1d[i][k] = 600.0;

            // LVZ

              else if (z[i][k] <= 6291000.0 && z[i][k] >= 6151000.0)    // 80-220 km
                  Q1d[i][k] = 80.0;

            // Transition zone

              else if (z[i][k] <= 6151000.0 && z[i][k] >= 5971000.0)    // 220-400 km
                  Q1d[i][k] = 143.0;

              else if (z[i][k] <= 5971000.0 && z[i][k] >= 5771000.0)    // 400-600 km
                  Q1d[i][k] = 143.0;	

              else if (z[i][k] <= 5771000.0 && z[i][k] >= 5701000.0)    // 600-670 km
                  Q1d[i][k] = 143.0;

            // Lower mantle

              else if (z[i][k] <= 5701000.0 && z[i][k] >= 5600000.0)    // 670-771 km
                  Q1d[i][k] = 312.0;	

              else if (z[i][k] <= 5600000.0 && z[i][k] >= 3630000.0)    // 771-2741 km
                  Q1d[i][k] = 312.0;	

              else if (z[i][k] <= 3630000.0 && z[i][k]>=3480000.0)    // 2741-2756 km
                  Q1d[i][k] = 312.0;	

            // Outer core

              else if (z[i][k] <= 3480000.0 && z[i][k] >= 1221500.0)
                  Q1d[i][k]=100000.0;

            // Inner core

              else if (z[i][k] <= 1221500.0)
                  Q1d[i][k] = 84.6;
              }
          }	

      else {
          FOR_ZD (i, k)
              Q1d[i][k] = 100000.0;
          }

    // translate to 3D arrays

      FOR_ZD (i, k) {
          rho1d[i][k] *= 1000.0;
          cp1d[i][k] *= 1000.0;
          cs1d[i][k] *= 1000.0;
          }

      FOR_MD (IM) {
          int i = MD_index3(IM);
          int k = MD_index6(IM);

          real rho = 1000.0 * rho1d[i][k];
          real cp = 1000.0 * cp1d[i][k];
          real cs = 1000.0 * cs1d[i][k];
          
          rhoinv[IM] = 1.0 /  rho;
          mu[IM] = cs * cs * rho;
          lambda[IM] = (cp * cp - 2 * cs * cs) * rho;
          Q[IM] = Q1d[i][k];
      
        // initialise anisotropic parameters
          A[IM] = 0.0;
          B[IM] = 0.0;
          C[IM] = 0.0;
          }

      delete_ZD(cp1d);
      delete_ZD(cs1d);
      delete_ZD(rho1d);
      delete_ZD(Q1d);
      }

// homogeneous model plus QL6 Q
  void homogeneous_plus_Q(void) {
      real **Q1d = new_ZD();

    // homogeneous model (elastic part)

      const real h_rho = 1.0;
      const real h_mu = 0.0;
      const real h_lambda = 0.0;
      const real h_A = 0.0;
      const real h_B = 0.0;
      const real h_C = 0.0;

      FOR_MD (IM) {
          rhoinv[IM] = 1.0 / h_rho;
          mu[IM] = h_mu;
          lambda[IM] = h_lambda;
          A[IM] = h_A;
          B[IM] = h_B;
          C[IM] = h_C;
          }
    
    // make Q model (smooth version of QL6)

    // make 1D profile
      if (is_diss) {
          FOR_ZD (i, k) {
              if (z[i][k] <= 6371000.0 && z[i][k] >= 6100000.0) {
                  real r = (6371.0 - z[i][k] / 1000.0) / 271.0;
                  real r2 = r * r;
                  real r3 = r2 * r;
                  real r4 = r3 * r;
                  real r5 = r4 * r;			  
                  Q1d[i][k] = 300.0 - 5370.82 * r2 + 
                      14401.62 * r3 - 13365.78 * r4 + 4199.98 * r5;	
                  }		     

              else if (z[i][k] <= 6100000.0 && z[i][k] >= 5701000.0)
                  Q1d[i][k] = 165.0;

              else if (z[i][k] <= 5701000.0 && z[i][k] >= 3480000.0)               
                  Q1d[i][k] = 355.0;

              else if (z[i][k] <= 3480000.0 && z[i][k] >= 1221000.0)
                  Q1d[i][k] = 0.0; 

              else
                  Q1d[i][k] = 104.0;
              }
          }
      else {
          FOR_ZD (i, k)
              Q1d[i][k] = 100000.0;
          }

    // translate to 3D array

      FOR_MD (IM) {
          int i = MD_index3(IM);
          int k = MD_index6(IM);
          Q[IM] = Q1d[i][k];
          }

      delete_ZD(Q1d);
      }

// European 1D background model
  void eumod_bg(void) {
      real **cp1d = new_ZD();
      real **cs1d = new_ZD();
      real **rho1d = new_ZD();
      real **Q1d = new_ZD();

    // make elastic model

      FOR_ZD (i, k) {
          real r = z[i][k] / 6371.0e3;
          real r2 = r * r;
          real r3 = r2 * r;

        // crust
        
          if (z[i][k] <= 6371000.0 && z[i][k] >= 6356000.0) {    // 0-15km
              rho1d[i][k] = 2.60;
              cp1d[i][k] = 5.80;
              cs1d[i][k] = 3.20;
              }

          else if (z[i][k] <= 6356000.0 && z[i][k] >= 6346600.0) {    // 15-24.4km      
              rho1d[i][k] = 2.90;
              cp1d[i][k] = 6.80;
              cs1d[i][k] = 3.90;
              }
               
        // LID

          else if (z[i][k] <= 6346600.0 && z[i][k] >= 6291000.0) {    // 24-80 km                   
              rho1d[i][k] = 2.6910 + 0.6924 * r;
              cp1d[i][k] = 4.1875 + 3.9382 * r - 0.035;
              cs1d[i][k] = 2.1519 + 2.3481 * r - 0.065;
              }

        // LVZ

          else if (z[i][k] <= 6291000.0 && z[i][k] >= 6191000.0) {    // 80-180 km
              rho1d[i][k] = 2.6910 + 0.6924 * r;
              cp1d[i][k] = 4.1875 + 3.9382 * r - 0.035;
              cs1d[i][k] = 2.1519 + 2.3481 * r - 0.065;
              }

        // Transition zone

          else if (z[i][k] <= 6191000.0 && z[i][k] >= 6051000.0) {    // 180-320 km
              rho1d[i][k] = 9.1790 - 5.9841 * r;
              cp1d[i][k] = 40.5988 - 33.5317 * r - 0.035;
              cs1d[i][k] = 16.8261 - 12.7527 * r - 0.065;
              }

          else if (z[i][k] <= 6051000.0 && z[i][k] >= 5971000.0) {    // 320-400 km
              rho1d[i][k] = 7.1089 - 3.8045 * r;
              cp1d[i][k] = 20.3926 - 12.2569 * r - 0.035;
              cs1d[i][k] = 8.9496 - 4.4597 * r - 0.065;
              }

          else if (z[i][k] <= 5971000.0 && z[i][k] >= 5771000.0) {    // 400-600 km
              rho1d[i][k] = 11.2494 - 8.0298 * r;
              cp1d[i][k] = 39.7027 - 32.6166 * r - 0.035;
              cs1d[i][k] = 22.3512 - 18.5856 * r - 0.12;
              }

          else if (z[i][k] <= 5771000.0 && z[i][k] >= 5701000.0) {    // 600-670 km
              rho1d[i][k] = 5.3197 - 1.4836 * r;
              cp1d[i][k] = 19.0957 - 9.8672 * r - 0.035;
              cs1d[i][k] = 9.9839 - 4.9324 * r - 0.12;
              }

        // Lower mantle

          else if (z[i][k] <= 5701000.0 && z[i][k] >= 5600000.0) {    // 670-771 km
              rho1d[i][k] = 7.9565 - 6.4761 * r + 5.5283 * r2 - 3.0807 * r3;
              cp1d[i][k] = 29.2766 - 23.6026 * r + 5.5242 * r2 - 2.5514 * r3;
              cs1d[i][k] = 22.3459 - 17.2473 * r - 2.0834 * r2 + 0.9783 * r3 - 0.12;
              }

          else if (z[i][k] <= 5600000.0 && z[i][k] >= 3630000.0) {    // 771-2741 km
              rho1d[i][k] = 7.9565 - 6.4761 * r + 5.5283 * r2 - 3.0807 * r3;
              cp1d[i][k] = 24.9520 - 40.4673 * r + 51.4832 * r2 - 26.6419 * r3;
              cs1d[i][k] = 11.1671 - 13.7818 * r + 17.4575 * r2 - 9.2777 * r3 - 0.12;
              }

          else if (z[i][k] <= 3630000.0 && z[i][k] >= 3480000.0) {    // 2741-2756 km
              rho1d[i][k] = 7.9565 - 6.4761 * r + 5.5283 * r2 - 3.0807 * r3;
              cp1d[i][k] = 15.3891 - 5.3181 * r + 5.5242 * r2 - 2.5514 * r3;
              cs1d[i][k] = 6.9254 + 1.4672 * r - 2.0834 * r2 + 0.9783 * r3 - 0.12;
              }

        // Outer core

          else if (z[i][k] <= 3480000.0 && z[i][k] >= 1221500.0) {
              rho1d[i][k] = 12.5815 - 1.2638 * r - 3.6426 * r2 - 5.5281 * r3;
              cp1d[i][k] = 11.0487 - 4.0362 * r + 4.8023 * r2 - 13.5732 * r3;
              cs1d[i][k] = 0.0;
              }

        // Inner core

          else if (z[i][k] <= 1221500.0) {
              rho1d[i][k] = 13.0885 - 8.8381 * r2;
              cp1d[i][k] = 11.2622 - 6.3640 * r2;
              cs1d[i][k] = 3.6678 - 4.4475 * r2;
              }

          }

    // make Q model (smooth version of QL6)

      FOR_ZD (i, k) {
 
          if (z[i][k] <= 6371000.0 && z[i][k] >= 6100000.0) {
              real r = (6371.0 - z[i][k] / 1000.0) / 271.0;
              real r2 = r * r;
              real r3 = r2 * r;
              real r4 = r3 * r;
              real r5 = r4 * r;			  
              Q1d[i][k] = 300.0 - 5370.82 * r2 + 
                   14401.62 * r3 - 13365.78 * r4 + 4199.98 * r5;
              }
                 
          else if (z[i][k] <= 6100000.0 && z[i][k] >= 5701000.0)
              Q1d[i][k] = 165.0;

          else if (z[i][k] <= 5701000.0 && z[i][k] >= 3480000.0)
              Q1d[i][k] = 355.0;

          else if (z[i][k] <= 3480000.0 && z[i][k] >= 1221000.0)
              Q1d[i][k] = 0.0;

          else
              Q1d[i][k] = 104.0;
          }

    // modification of the crustal layer

      if (z[0][0] == 6371000) {
        // surface
          for (int k = 0; k <= lpd; k++) {
              rho1d[0][k] = 3.00;
              cp1d[0][k] = 7.20;
              cs1d[0][k] = 4.10;
              }
          }

      FOR_MD (IM) {
          int i = MD_index3(IM);
          int k = MD_index6(IM);

          real rho = 1000.0 * rho1d[i][k];
          real cp = 1000.0 * cp1d[i][k];
          real cs = 1000.0 * cs1d[i][k];

        // translate to 3D arrays

          rhoinv[IM] = 1 / rho;
          mu[IM] = cs * cs * rho;
          lambda[IM] = (cp * cp - 2 * cs * cs) * rho;
          Q[IM] = Q1d[i][k];
          }

    // initialize anisotropic parameters

      FOR_MD (IM) {
          A[IM] = 0.0;
          B[IM] = 0.0;
          C[IM] = 0.0;
          }

      delete_ZD(cp1d);
      delete_ZD(cs1d);
      delete_ZD(rho1d);
      delete_ZD(Q1d);
      }

// AK135 model
  void ak135(void) {
      real **cp1d = new_ZD();
      real **cs1d = new_ZD();
      real **rho1d = new_ZD();

      static real c_ak135_r[] = {
          6371.0, 6351.0, 6351.0, 6336.0, 6336.0, 
          6293.5, 6251.0, 6251.0, 6206.0, 6161.0, 
          6161.0, 6111.0, 6061.0, 6011.0, 5961.0, 
          5961.0, 5911.0, 5861.0, 5811.0, 5761.0, 
          5711.0, 5711.0, 5661.0, 5611.0, 5561.5, 
          5512.0, 5462.5, 5413.0, 5363.5, 5314.0, 
          5264.5, 5215.0, 5165.5, 5116.0, 5066.5, 
          5017.0, 4967.5, 4918.0, 4868.5, 4819.0, 
          4769.5, 4720.0, 4670.5, 4621.0, 4571.5, 
          4522.0, 4472.5, 4423.0, 4373.5, 4324.0, 
          4274.5, 4225.0, 4175.5, 4126.0, 4076.5, 
          4027.0, 3977.5, 3928.0, 3878.5, 3829.0, 
          3779.5, 3731.0, 3681.0, 3631.0, 3631.0, 
          3581.3, 3531.7, 3479.5, 3479.5, 3431.6, 
          3381.3, 3331.0, 3280.6, 3230.3, 3180.0, 
          3129.7, 3079.4, 3029.0, 2978.7, 2928.4, 
          2878.3, 2827.7, 2777.4, 2727.0, 2676.7, 
          2626.4, 2576.0, 2525.7, 2475.4, 2425.0, 
          2374.7, 2324.4, 2274.1, 2223.7, 2173.4, 
          2123.1, 2072.7, 2022.4, 1972.1, 1921.7, 
          1871.4, 1821.1, 1770.7, 1720.4, 1670.1, 
          1619.8, 1569.4, 1519.1, 1468.8, 1418.4, 
          1368.1, 1317.8, 1267.4, 1217.5, 1217.5, 
          1166.4, 1115.7, 1064.9, 1014.3,  963.5, 
          912.83, 862.11, 811.40, 760.69, 709.98, 
          659.26, 608.55, 557.84, 507.13, 456.41, 
          405.70, 354.99, 304.28, 253.56, 202.85,
          152.14, 101.43,  50.71, 0.0
          };

      real ak135_r[139];

      for (int i = 0; i < 139; i++)
          ak135_r[i] = 1000 * c_ak135_r[i];

      real c_ak135_cp[] = {
          5.800000, 5.800000, 6.500000, 6.500000, 8.040000, 
          8.045000, 8.050000, 8.050000, 8.175000, 8.300700, 
          8.300700, 8.482200, 8.665000, 8.847600, 9.030200, 
          9.360100, 9.528000, 9.696200, 9.864000, 10.032000, 
          10.200000, 10.790900, 10.922200, 11.055300, 11.135500, 
          11.222800, 11.306800, 11.389700, 11.470400, 11.549300, 
          11.626500, 11.702000, 11.776800, 11.849100, 11.920800, 
          11.989100, 12.057100, 12.124700, 12.191200, 12.255800, 
          12.318100, 12.381300, 12.442700, 12.503000, 12.563800, 
          12.622600, 12.680700, 12.738400, 12.795600, 12.852400, 
          12.909300, 12.966300, 13.022600, 13.078600, 13.133700, 
          13.189500, 13.246500, 13.301700, 13.358400, 13.415600, 
          13.474100, 13.531100, 13.589900, 13.649800, 13.649800, 
          13.653300, 13.657000, 13.660100, 8.000000, 8.038200, 
          8.128300, 8.221300, 8.312200, 8.400100, 8.486100, 
          8.569200, 8.649600, 8.728300, 8.803600, 8.876100, 
          8.946100, 9.013800, 9.079200, 9.142600, 9.204200, 
          9.263400, 9.320500, 9.376000, 9.429700, 9.481400, 
          9.530600, 9.577700, 9.623200, 9.667300, 9.710000, 
          9.751300, 9.791400, 9.830400, 9.868200, 9.905100, 
          9.941000, 9.976100, 10.010300, 10.043900, 10.076800, 
          10.109500, 10.141500, 10.173900, 10.204900, 10.232900, 
          10.256500, 10.274500, 10.285400, 10.289000, 11.042700, 
          11.058500, 11.071800, 11.085000, 11.098300, 11.116600, 
          11.131600, 11.145700, 11.159000, 11.171500, 11.183200, 
          11.194100, 11.204100, 11.213400, 11.221900, 11.229500, 
          11.236400, 11.242400, 11.247700, 11.252100, 11.255700, 
          11.258600, 11.260600, 11.261800, 11.262200
          };

      real ak135_cp[139];

      for (int i = 0; i < 139; i++)
          ak135_cp[i] = 1000 * c_ak135_cp[i];

      real c_ak135_cs[] = {
          3.460000, 3.460000, 3.850000, 3.850000, 4.480000, 
          4.490000, 4.500000, 4.500000, 4.509000, 4.518400, 
          4.518400, 4.609400, 4.696400, 4.783200, 4.870200, 
          5.080600, 5.186400, 5.292200, 5.398900, 5.504700, 
          5.610400, 5.960700, 6.089800, 6.210000, 6.242400, 
          6.279900, 6.316400, 6.351900, 6.386000, 6.418200, 
          6.451400, 6.482200, 6.513100, 6.543100, 6.572800, 
          6.600900, 6.628500, 6.655400, 6.681300, 6.707000, 
          6.732300, 6.757900, 6.782000, 6.805600, 6.828900, 
          6.851700, 6.874300, 6.897200, 6.919400, 6.941600, 
          6.962500, 6.985200, 7.006900, 7.028600, 7.050400, 
          7.072200, 7.093200, 7.114400, 7.136800, 7.158400, 
          7.180400, 7.203100, 7.225300, 7.248500, 7.248500, 
          7.259300, 7.270000, 7.281700, 0.000000, 0.000000, 
          0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
          0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
          0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
          0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
          0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
          0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
          0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
          0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
          0.000000, 0.000000, 0.000000, 0.000000, 3.504300, 
          3.518700, 3.531400, 3.543500, 3.555100, 3.566100, 
          3.576500, 3.586400, 3.595700, 3.604400, 3.612600, 
          3.620200, 3.627200, 3.633700, 3.639600, 3.645000, 
          3.649800, 3.654000, 3.657700, 3.660800, 3.663300, 
          3.665300, 3.666700, 3.667500, 3.667800
          };

      real ak135_cs[139];

      for (int i = 0; i < 139; i++)
          ak135_cs[i] = 1000 * c_ak135_cs[i];

      real c_ak135_rho[] = {
          2.720000, 2.720000, 2.920000, 2.920000, 3.320000, 
          3.345000, 3.371000, 3.371100, 3.371100, 3.324300, 
          3.324300, 3.366300, 3.411000, 3.457700, 3.506800, 
          3.931700, 3.927300, 3.923300, 3.921800, 3.920600, 
          3.920100, 4.238700, 4.298600, 4.356500, 4.411800, 
          4.465000, 4.516200, 4.565400, 4.592600, 4.619800, 
          4.646700, 4.673500, 4.700100, 4.726600, 4.752800, 
          4.779000, 4.805000, 4.830700, 4.856200, 4.881700, 
          4.906900, 4.932100, 4.957000, 4.981700, 5.006200, 
          5.030600, 5.054800, 5.078900, 5.102700, 5.126400, 
          5.149900, 5.173200, 5.196300, 5.219200, 5.242000, 
          5.264600, 5.287000, 5.309200, 5.331300, 5.353100, 
          5.374800, 5.396200, 5.417600, 5.438700, 5.693400, 
          5.719600, 5.745800, 5.772100, 9.914500, 9.994200, 
          10.072200, 10.148500, 10.223300, 10.296400, 10.367900, 
          10.437800, 10.506200, 10.573100, 10.638500, 10.702300, 
          10.764700, 10.825700, 10.885200, 10.943400, 11.000100, 
          11.055500, 11.109500, 11.162300, 11.213700, 11.263900, 
          11.312700, 11.360400, 11.406900, 11.452100, 11.496200, 
          11.539100, 11.580900, 11.621600, 11.661200, 11.699800, 
          11.737300, 11.773700, 11.809200, 11.843700, 11.877200, 
          11.909800, 11.941400, 11.972200, 12.000100, 12.031100, 
          12.059300, 12.086700, 12.113300, 12.139100, 12.703700, 
          12.728900, 12.753000, 12.776000, 12.798000, 12.818800, 
          12.838700, 12.857400, 12.875100, 12.891700, 12.907200, 
          12.921700, 12.935100, 12.947400, 12.958600, 12.968800, 
          12.977900, 12.985900, 12.992900, 12.998800, 13.003600, 
          13.007400, 13.010000, 13.011700, 13.012200
          };

      real ak135_rho[139];

      for (int i = 0; i < 139; i++)
          ak135_rho[i] = 1000 * c_ak135_rho[i];

    // loop over depth intervals

      FOR_ZD (i, k) {
          for (int n = 0; n < 138; n++) {    
              if (z[i][k] >= ak135_r[n+1] && z[i][k] <= ak135_r[n]) {
                  if (ak135_r[n] - ak135_r[n+1] == 0) {
                      cp1d[i][k] = ak135_cp[n];
                      cs1d[i][k] = ak135_cs[n];
                      rho1d[i][k] = ak135_rho[n];
                      }
                  else {                        
                      real ratio = (ak135_r[n] - z[i][k]) / (ak135_r[n] - ak135_r[n+1]);
                      cp1d[i][k] = ak135_cp[n] * (1 - ratio) + ak135_cp[n+1] * ratio;
                      cs1d[i][k] = ak135_cs[n] * (1 - ratio) + ak135_cs[n+1] * ratio;
                      rho1d[i][k] = ak135_rho[n] * (1 - ratio) + ak135_rho[n+1] * ratio;
                      }
                  }
              }
          }

    // translate to 3D arrays
      FOR_MD (IM) {
          int i = MD_index3(IM);
          int k = MD_index6(IM);
          
          real rho = rho1d[i][k];
          real cp = cp1d[i][k];
          real cs = cs1d[i][k];
          
          rhoinv[IM] = 1 / rho;
          mu[IM] = cs * cs * rho;
          lambda[IM] = (cp * cp - 2 * cs * cs) * rho;
          }

    // fill all other variables
      FOR_MD (IM) {
          A[IM] = 0.0;
          B[IM] = 0.0;
          C[IM] = 0.0;
      
          if (is_diss)
              Q[IM] = 100000.0;
          }

      delete_ZD(cp1d);
      delete_ZD(cs1d);
      delete_ZD(rho1d);
      }
